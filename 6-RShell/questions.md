1. How does the remote client determine when a command's output is fully received from the server, and what techniques can be used to handle partial reads or ensure complete message transmission?

_The remote client knows that it has received all of a command's output because the server sends a special marker, such as a unique character like the one defined by `RDSH_EOF_CHAR`, at the very end of the message. The client continuously calls `recv()` in a loop and adds the data it gets to a buffer until it detects that marker. Other techniques to handle data that might come in parts include sending a fixed-length header that tells the client exactly how many bytes to expect or using a unique delimiter that clearly marks the end of a message. These methods ensure that even if the output is split into several pieces, the client can assemble it into a complete message._

2. This week's lecture on TCP explains that it is a reliable stream protocol rather than a message-oriented one. Since TCP does not preserve message boundaries, how should a networked shell protocol define and detect the beginning and end of a command sent over a TCP connection? What challenges arise if this is not handled correctly?

_TCP is a continuous stream of data without clear separations between individual messages. Because of this, a networked shell protocol needs to define its own way to tell where one command ends and the next begins. This can be done by including a unique termination character (like `RDSH_EOF_CHAR`) at the end of each command, or by adding a fixed-size header that indicates the length of the message. If these message boundaries aren't defined properly, the server might mix parts of different commands together or split a single command across multiple reads, which can lead to errors in command execution and make the protocol unreliable._

3. Describe the general differences between stateful and stateless protocols.

_Stateful protocols keep track of previous interactions, which means the server remembers information about the current client session. This can be useful for tasks that need context—like logging in or keeping track of user actions—but it also means more memory is used and the system can get more complex. Stateless protocols, on the other hand, treat every request as completely new and unrelated to any previous request. While this makes the system simpler and easier to scale, it also means that every request must include all the necessary information since the server isn't keeping any history of past interactions._

4. Our lecture this week stated that UDP is "unreliable". If that is the case, why would we ever use it?

_Even though UDP is considered "unreliable" because it doesn't guarantee that every packet will reach its destination, it is still very useful in situations where speed and low overhead are more important than perfect accuracy. UDP is great for real-time applications like video streaming, voice calls, or online games because it allows data to be sent quickly without waiting for confirmation that every piece arrived. In addition, UDP supports broadcasting and multicasting, which lets one message be sent to many recipients at once—something that TCP doesn't handle as efficiently. In cases where the application itself can handle minor packet losses, UDP's advantages make it a solid choice._

5. What interface/abstraction is provided by the operating system to enable applications to use network communications?

_The operating system provides an abstraction called sockets that makes it easier for applications to use network communications. This API offers a standard set of functions like `socket()`, `bind()`, `listen()`, `accept()`, `connect()`, `send()`, and `recv()` that hide much of the complexity of network protocols and hardware. With these functions, programmers can open network connections, send and receive data, and manage communication sessions without needing to deal with low-level details, making network programming more accessible and standardized._